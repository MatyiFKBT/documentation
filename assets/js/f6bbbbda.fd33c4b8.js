"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[9616],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var o=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=c(n),d=i,m=h["".concat(s,".").concat(d)]||h[d]||u[d]||a;return n?o.createElement(m,r(r({ref:t},p),{},{components:n})):o.createElement(m,r({ref:t},p))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var c=2;c<a;c++)r[c]=n[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3807:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var o=n(87462),i=(n(67294),n(3905));const a={title:"Faster! Optimizing React app to the bone",description:"How to optimize React app and make it faster. How to identify slow components and optimize infinite scrolling in your application.",authors:["sgranat"],tags:["react.js","javascript","typescript","opensource"],image:"/img/blog/optimizations/thumbnail.png"},r=void 0,l={permalink:"/blog/2021/11/24/optimizing-react-to-the-bone",editUrl:"https://github.com/tolgee/documentation/tree/main/blog/2021-11-24-optimizing-react-to-the-bone.md",source:"@site/blog/2021-11-24-optimizing-react-to-the-bone.md",title:"Faster! Optimizing React app to the bone",description:"How to optimize React app and make it faster. How to identify slow components and optimize infinite scrolling in your application.",date:"2021-11-24T00:00:00.000Z",formattedDate:"November 24, 2021",tags:[{label:"react.js",permalink:"/blog/tags/react-js"},{label:"javascript",permalink:"/blog/tags/javascript"},{label:"typescript",permalink:"/blog/tags/typescript"},{label:"opensource",permalink:"/blog/tags/opensource"}],readingTime:5.53,hasTruncateMarker:!0,authors:[{name:"\u0160t\u011bp\xe1n Gran\xe1t",title:"Frontend Architect",url:"https://github.com/stepan662",imageURL:"https://avatars.githubusercontent.com/u/8831144?v=4",key:"sgranat"}],frontMatter:{title:"Faster! Optimizing React app to the bone",description:"How to optimize React app and make it faster. How to identify slow components and optimize infinite scrolling in your application.",authors:["sgranat"],tags:["react.js","javascript","typescript","opensource"],image:"/img/blog/optimizations/thumbnail.png"},prevItem:{title:"Same logic in 4 major FE frameworks, how do they compare?",permalink:"/blog/2021/11/29/same-logic-in-4-frameworks"},nextItem:{title:"Localize your React.js App the simplest way you've ever seen",permalink:"/blog/localize-your-reactjs-app-the-simplest-way-you've-ever-seen"}},s={authorsImageUrls:[void 0]},c=[{value:"What are we dealing with",id:"what-are-we-dealing-with",level:3},{value:"How to identify problems generally",id:"how-to-identify-problems-generally",level:3},{value:"One problem at a time",id:"one-problem-at-a-time",level:2},{value:"Optimizing state management",id:"optimizing-state-management",level:3},{value:"Large number of children re-render",id:"large-number-of-children-re-render",level:3},{value:"Infinite scolling",id:"infinite-scolling",level:3},{value:"Reducing rows complexity",id:"reducing-rows-complexity",level:3},{value:"Conclusion",id:"conclusion",level:2}],p={toc:c};function u(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,o.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Thumbnail",src:n(88281).Z,width:"2003",height:"881"})),(0,i.kt)("p",null,"In Tolgee localization platform, we manage translations. So our most important view is a list of translations, every row contains key and related translations in different languages. As this view serves multiple purposes, we have quite a lot of requirements and fulfilling all of them required quite a bit of optimizations, which I'd like to share with you today."),(0,i.kt)("h3",{id:"what-are-we-dealing-with"},"What are we dealing with"),(0,i.kt)("p",null,'Mainly, a whole view is using infinite scrolling, where we automatically fetch additional data when user scrolls down. Every row needs to have some buttons, so he can edit, select or modify state of translations. We have search and filters, which should work swiftly when applied. Then we have resible columns, which allow user to change whole layout by mouse dragging. We also need to detect overflowing text vertically, which can\'t be done simply through css, but we need to "test render" it first and then see if it fits. And last but not least (as new features will surely come in the future), everything need to work with focus, so user can controll it through keyboard.'),(0,i.kt)("h3",{id:"how-to-identify-problems-generally"},"How to identify problems generally"),(0,i.kt)("p",null,"Basically always when your React application is slow it's due to too many components re-rendering or too often. React have very useful Developer Tools, where you can profile your App and then find out which components are taking most of the time to render."),(0,i.kt)("p",null,"When I identified slow components, I needed to understand why exactly is rendering so slow.\nOne might think that if we keep our components small, the amount of rendering should be managable, but as it turned out this was not the case. Main problem is that components often depend on one another (like parent and child or using same data) and when small change in your state causes a big chunk of your app to re-render, you might have to apply additional optimizations, which React doesn't make automatically."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"To make sure that my optimizations are actually working I've brought my super old laptop to work, which I've considered the most reliable benchmark of improvement")),(0,i.kt)("h2",{id:"one-problem-at-a-time"},"One problem at a time"),(0,i.kt)("p",null,"I will now try to ilustrate different situations on the example of our app and offer a way which we choosed as a solution. It is important to understand what exactly is happening, because optimizations are often tradeoffs - you exchange comfort (elegance/convenience/generality) for speed. So if you do incorrect optimizations, you might improve nothing and only ruining your code."),(0,i.kt)("h3",{id:"optimizing-state-management"},"Optimizing state management"),(0,i.kt)("p",null,"When we simply use Context API for our main state, we end up re-rendering almost entire view on every change. This issue is mostly visible when we use search field, as typing will become unbearably slow."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Slow typing",src:n(54363).Z,width:"640",height:"302"})),(0,i.kt)("p",null,"You can solve this by using some state management tool (e.g. Redux, MobX, ...), or you can use context in a clever way, so you minimize re-rendering (check my previous ",(0,i.kt)("a",{parentName:"p",href:"https://dev.to/tolgee_i18n/react-doesnt-need-state-management-tool-i-said-31l4"},"article"),")."),(0,i.kt)("h3",{id:"large-number-of-children-re-render"},"Large number of children re-render"),(0,i.kt)("p",null,"Clever state management still won't protect us completely against unnecessary re-renders. In some cases the fact the Component update causes all children re-render can be too expensive. You can avoid this by wrapping each child with ",(0,i.kt)("inlineCode",{parentName:"p"},"React.memo")," - React will then render child only when props change. However, make sure that you fully understand how it works in the ",(0,i.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/react-api.html#reactmemo"},"docs"),", and then check that it really helped."),(0,i.kt)("p",null,"In our case we wrap each row in the list with ",(0,i.kt)("inlineCode",{parentName:"p"},"React.memo"),". Because the row is relying mostly on fetched data, we can save quite a lot of unnecessary re-rendering."),(0,i.kt)("h3",{id:"infinite-scolling"},"Infinite scolling"),(0,i.kt)("p",null,"Our main problem now is that our page can have bascially infinite number of components. A way to solve this is to only render elements, that are currently visible to the user. It's better to use some third party solution for this, because it's quite complicated to do right. After some trial and error we ended up with library ",(0,i.kt)("inlineCode",{parentName:"p"},"react-list"),"."),(0,i.kt)("p",null,"Libraries like these usually require you to specify size of the components upfront (as they need to calculate a full length of the scrollable area without actually rendering the content), which can be quite problematic - in our case row sizes are variable and so we can't really tell how big it will be untill we render it. ",(0,i.kt)("inlineCode",{parentName:"p"},"react-list")," is able to solve this by only asking you to estimate the size of rows and then when it actually renders the element, it updates the size automatically. This can lead to your scrollbar jumping (as a height of the container is changing while you are scrolling in it), but if your estimation is somehow decent, it is pretty minor issue."),(0,i.kt)("p",null,'Nice! So now we decreased an overall number of components displayed from infinity to "it depends on your screen size". However we have another problem ...'),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Slow scrolling",src:n(46898).Z,width:"640",height:"302"})),(0,i.kt)("h3",{id:"reducing-rows-complexity"},"Reducing rows complexity"),(0,i.kt)("p",null,"Our infinite scrolling optimization wasn't without tradeoff. It takes siginificant time to render each row and because user can scroll quite fast, it can lead to content not keeping up with scrolling. Problem that is related to this is our resizeble layout which is also very slow."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Slow resizing",src:n(53442).Z,width:"640",height:"302"})),(0,i.kt)("p",null,"This is quite difficult problem, because only thing that you can do here is to reduce complexity of individual rows. In our case we've mostly solved it by clever usage of css ",(0,i.kt)("inlineCode",{parentName:"p"},"grid"),", which allowed us create complex layouts using only few html elements."),(0,i.kt)("p",null,"Another thing was to prevent displaying unnecessary stuff on first render. All our buttons are hidden by default and only appear when you hover the given row. We were doing this only by css, which doesn't help React at all. So my solution was to hide the buttons for real (not render them) and show them only ",(0,i.kt)("inlineCode",{parentName:"p"},"onmouseover"),", which improved situation quite significantly."),(0,i.kt)("p",null,"This solution brought a new problem, that you were not able to use focus with ",(0,i.kt)("inlineCode",{parentName:"p"},"tab"),", as buttons were not actually present. I've solved this by always rendering first and last button (but hiding them with css) and other buttons would render when focus is within the row itself or when mouseover - this way user won't recognize the difference."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"I was quite scared when I realized that our Application is becoming very slow and at the end I've spend one full week with these optimizations, but after some trial and error I've understood weak points and was able to target them. Considering the complexity it works fine even on my super old university laptop and I've learned a lot."),(0,i.kt)("p",null,"I'm now proud developer and I spend quite a lot of my working time just scrolling around in our App."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Fast scrolling",src:n(44428).Z,width:"640",height:"326"})))}u.isMDXComponent=!0},53442:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/resizing-2fd02110bd6fd3fc631da31895b63314.gif"},44428:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/scrolling-fast-b9aa71c1d99b083ccd0a1b86b9a5a92a.gif"},46898:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/scrolling-a194a894b1858a692760bfa7ee0c693a.gif"},88281:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/thumbnail-8ae186a51de63f1c4521f92474d8e844.png"},54363:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/typing-8049df649c1685969656ec6da915acf9.gif"}}]);