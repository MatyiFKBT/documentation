"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[2677],{3905:(t,e,n)=>{n.d(e,{Zo:()=>c,kt:()=>d});var i=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,i)}return n}function a(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,i,r=function(t,e){if(null==t)return{};var n,i,r={},o=Object.keys(t);for(i=0;i<o.length;i++)n=o[i],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(i=0;i<o.length;i++)n=o[i],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var l=i.createContext({}),p=function(t){var e=i.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):a(a({},e),t)),n},c=function(t){var e=p(t.components);return i.createElement(l.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return i.createElement(i.Fragment,{},e)}},g=i.forwardRef((function(t,e){var n=t.components,r=t.mdxType,o=t.originalType,l=t.parentName,c=s(t,["components","mdxType","originalType","parentName"]),g=p(n),d=r,h=g["".concat(l,".").concat(d)]||g[d]||u[d]||o;return n?i.createElement(h,a(a({ref:e},c),{},{components:n})):i.createElement(h,a({ref:e},c))}));function d(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=n.length,a=new Array(o);a[0]=g;var s={};for(var l in e)hasOwnProperty.call(e,l)&&(s[l]=e[l]);s.originalType=t,s.mdxType="string"==typeof t?t:r,a[1]=s;for(var p=2;p<o;p++)a[p]=n[p];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}g.displayName="MDXCreateElement"},11828:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var i=n(87462),r=(n(67294),n(3905));const o={slug:"optimizing-spring-boot-tests",title:"Optimizing Spring Boot tests",description:"How did I optimized our Spring Boot tests to run a bit faster using bean lazy loading.",authors:["jcizmar"],image:"/img/blog/optimizing-spring-boot-tests.png",tags:["react","angular","svelte","vue","javascript","typescript","integration"]},a=void 0,s={permalink:"/blog/optimizing-spring-boot-tests",editUrl:"https://github.com/tolgee/documentation/tree/main/blog/2022-02-21-optimizing-spring-boot-tests.md",source:"@site/blog/2022-02-21-optimizing-spring-boot-tests.md",title:"Optimizing Spring Boot tests",description:"How did I optimized our Spring Boot tests to run a bit faster using bean lazy loading.",date:"2022-02-21T00:00:00.000Z",formattedDate:"February 21, 2022",tags:[{label:"react",permalink:"/blog/tags/react"},{label:"angular",permalink:"/blog/tags/angular"},{label:"svelte",permalink:"/blog/tags/svelte"},{label:"vue",permalink:"/blog/tags/vue"},{label:"javascript",permalink:"/blog/tags/javascript"},{label:"typescript",permalink:"/blog/tags/typescript"},{label:"integration",permalink:"/blog/tags/integration"}],readingTime:1.99,hasTruncateMarker:!0,authors:[{name:"Jan Cizmar \ud83d\ude0e",title:"Founder & Full-stack Architect",url:"https://github.com/JanCizmar",imageURL:"https://avatars.githubusercontent.com/u/18496315?v=4",key:"jcizmar"}],frontMatter:{slug:"optimizing-spring-boot-tests",title:"Optimizing Spring Boot tests",description:"How did I optimized our Spring Boot tests to run a bit faster using bean lazy loading.",authors:["jcizmar"],image:"/img/blog/optimizing-spring-boot-tests.png",tags:["react","angular","svelte","vue","javascript","typescript","integration"]},prevItem:{title:"In-context translating on production",permalink:"/blog/in-context-production"},nextItem:{title:"Is Turborepo overhyped?",permalink:"/blog/turborepo-overhyped"}},l={authorsImageUrls:[void 0]},p=[{value:"1. Moved from TestNG to JUnit",id:"1-moved-from-testng-to-junit",level:2},{value:"2. Splitting up tests which are recreating the Context and the others",id:"2-splitting-up-tests-which-are-recreating-the-context-and-the-others",level:2},{value:"3. Using Bean Lazy Loading",id:"3-using-bean-lazy-loading",level:2},{value:"What would be even better",id:"what-would-be-even-better",level:2}],c={toc:p};function u(t){let{components:e,...o}=t;return(0,r.kt)("wrapper",(0,i.Z)({},c,o,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Optimizing Spring Boot Tests",src:n(29131).Z,width:"979",height:"477"})),(0,r.kt)("p",null,"In this article, I would like to describe how I optimized our Spring Boot tests to run a bit faster."),(0,r.kt)("h2",{id:"1-moved-from-testng-to-junit"},"1. Moved from TestNG to JUnit"),(0,r.kt)("p",null,"I was using TestNG before, because we used it in NetSuite, where I worked before, but while using it with Spring Boot and\nKotlin I found a few annoying drawbacks."),(0,r.kt)("p",null,"First, I wasn't able to split the tests without writing custom XML suites, where I would have to specify the classes to\ntest. I don't like editing XMLs and I don't like mentioning each class or package to test.\nInstead, I wanted to split the tests by its class annotation, but I couldn't find a way\nhow to do that with TestNG."),(0,r.kt)("p",null,"Second, I wanted to use ",(0,r.kt)("a",{parentName:"p",href:"https://mockk.io/"},"mockk")," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Ninja-Squad/springmockk"},"springmockk"),", but\nit's ",(0,r.kt)("inlineCode",{parentName:"p"},"MockkBeant")," annotation wasn't working with TestNG."),(0,r.kt)("p",null,"Third, JUnit is used in most of the articles about testing with Spring Boot."),(0,r.kt)("p",null,"Moving from TestNG to JUnit doesn't make the tests faster, but it was needed to split the tests."),(0,r.kt)("h2",{id:"2-splitting-up-tests-which-are-recreating-the-context-and-the-others"},"2. Splitting up tests which are recreating the Context and the others"),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"@DirtiesContext")," annotation is used or different properties are provided for ",(0,r.kt)("inlineCode",{parentName:"p"},"@SpringBootTest"),", the whole application\ncontext recreated and is similarly slow as starting of the real application. We are not using Embedded DB for integration tests\nbecause we want to be sure, that the code works for our production DB, and also we are running DB migration on the application\nstartup. Because of that and all the component scanning, the app start-up takes about 15 seconds, so it's good to run tests\nwhich are recreating the context separately, which makes the non-recreating tests run faster, since they are not\ninterrupted by application starting."),(0,r.kt)("h2",{id:"3-using-bean-lazy-loading"},"3. Using Bean Lazy Loading"),(0,r.kt)("p",null,"Since Spring Boot 2.2, we can set ",(0,r.kt)("inlineCode",{parentName:"p"},"spring.main.lazy-initialization")," property to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," and spring is then creating Beans,\nonly when they're needed. This makes the context creation a bit faster as well."),(0,r.kt)("h2",{id:"what-would-be-even-better"},"What would be even better"),(0,r.kt)("p",null,"In the future, it would be better to make the application startup even faster. So I am thinking about creating a Postgres\ncontainer already containing the DB structure and truncating the tables instead of dropping and rerunning the migrations."),(0,r.kt)("p",null,"Also, it would be great, if we had more unit tests, so the whole codebase wasn't tested using integration tests, which requires the application context to be created."))}u.isMDXComponent=!0},29131:(t,e,n)=>{n.d(e,{Z:()=>i});const i=n.p+"assets/images/optimizing-spring-boot-tests-2beaa0eff0d3364ec0d816f687cd90e7.png"}}]);