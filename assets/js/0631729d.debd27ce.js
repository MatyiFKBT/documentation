"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[8662],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=c(n),d=r,h=m["".concat(l,".").concat(d)]||m[d]||u[d]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4282:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={title:"Same logic in 4 major FE frameworks, how do they compare?",description:"Real world comparison between 4 major front-end frameworks - React, Angular, Svelte and Vue. Example on Tolgee\u2019s integration libraries.",authors:["sgranat","jcizmar"],tags:["react.js","angular","vue.js","svelte","SDK","i18n"]},i=void 0,s={permalink:"/blog/2021/11/29/same-logic-in-4-frameworks",editUrl:"https://github.com/tolgee/documentation/tree/main/blog/2021-11-29-same-logic-in-4-frameworks.md",source:"@site/blog/2021-11-29-same-logic-in-4-frameworks.md",title:"Same logic in 4 major FE frameworks, how do they compare?",description:"Real world comparison between 4 major front-end frameworks - React, Angular, Svelte and Vue. Example on Tolgee\u2019s integration libraries.",date:"2021-11-29T00:00:00.000Z",formattedDate:"November 29, 2021",tags:[{label:"react.js",permalink:"/blog/tags/react-js"},{label:"angular",permalink:"/blog/tags/angular"},{label:"vue.js",permalink:"/blog/tags/vue-js"},{label:"svelte",permalink:"/blog/tags/svelte"},{label:"SDK",permalink:"/blog/tags/sdk"},{label:"i18n",permalink:"/blog/tags/i-18-n"}],readingTime:12.515,hasTruncateMarker:!0,authors:[{name:"\u0160t\u011bp\xe1n Gran\xe1t",title:"Frontend Architect",url:"https://github.com/stepan662",imageURL:"https://avatars.githubusercontent.com/u/8831144?v=4",key:"sgranat"},{name:"Jan Cizmar \ud83d\ude0e",title:"Founder & Full-stack Architect",url:"https://github.com/JanCizmar",imageURL:"https://avatars.githubusercontent.com/u/18496315?v=4",key:"jcizmar"}],frontMatter:{title:"Same logic in 4 major FE frameworks, how do they compare?",description:"Real world comparison between 4 major front-end frameworks - React, Angular, Svelte and Vue. Example on Tolgee\u2019s integration libraries.",authors:["sgranat","jcizmar"],tags:["react.js","angular","vue.js","svelte","SDK","i18n"]},prevItem:{title:"\ud83c\udf0e Why you should prepare your project for localization (i18n) right now",permalink:"/blog/why-you-should-prepare-your-project-for-localization-right-now"},nextItem:{title:"Faster! Optimizing React app to the bone",permalink:"/blog/2021/11/24/optimizing-react-to-the-bone"}},l={authorsImageUrls:[void 0,void 0]},c=[{value:"Overall design",id:"overall-design",level:2},{value:"General integration library architecture",id:"general-integration-library-architecture",level:2},{value:"Translating regular texts",id:"translating-regular-texts",level:3},{value:"Translating imperatively",id:"translating-imperatively",level:3},{value:"Source of data",id:"source-of-data",level:3},{value:"Implementation for React",id:"implementation-for-react",level:2},{value:"Imperative translating in React",id:"imperative-translating-in-react",level:3},{value:"Notes",id:"notes",level:4},{value:"Implementation for Vue.js",id:"implementation-for-vuejs",level:2},{value:"Imperative translating in Vue",id:"imperative-translating-in-vue",level:3},{value:"Implementation in",id:"implementation-in",level:2},{value:"Imperative translating in Svelte",id:"imperative-translating-in-svelte",level:3},{value:"Angular",id:"angular",level:2},{value:"The NgxTolgeeModule",id:"the-ngxtolgeemodule",level:3},{value:"The translation service and Observables",id:"the-translation-service-and-observables",level:3},{value:"The component with <code>t</code> attribute selector",id:"the-component-with-t-attribute-selector",level:3},{value:"The <code>translate</code> pipe",id:"the-translate-pipe",level:3},{value:"Conclusion",id:"conclusion",level:2}],p={toc:c};function u(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In ",(0,r.kt)("a",{parentName:"p",href:"https://tolgee.io"},"Tolgee.io")," we needed to implement integrations for all major frontend frameworks.\nI'd say, that this is quite a good opportunity to show a real world comparison between them and it will allow us to\ndive into a bit more advanced functionality."),(0,r.kt)("h2",{id:"overall-design"},"Overall design"),(0,r.kt)("p",null,"Tolgee is a localization platform. Our integration libraries have two purposes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Display and format translations in the application + manage language changes"),(0,r.kt)("li",{parentName:"ul"},'In dev mode allow "in-context" localization - which means, that user can edit translations directly in the app')),(0,r.kt)("p",null,"So in dev mode our library needs to communicate with our server, but in production mode it will only deal with generated\nJSON files, containing translations."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Tolgee schema",src:n(88630).Z,width:"651",height:"448"})),(0,r.kt)("h2",{id:"general-integration-library-architecture"},"General integration library architecture"),(0,r.kt)("p",null,"Integration libraries provide tailored API for given framework and only need to React on translation/language changes,\ncoming from core library."),(0,r.kt)("h3",{id:"translating-regular-texts"},"Translating regular texts"),(0,r.kt)("p",null,"Every integration needs to provide a way to translate regular texts on the page in form of special component, so user\ncan simply use the component and we need to make sure, that correct translation is displayed (based on selected\nlanguage). We are using ",(0,r.kt)("a",{parentName:"p",href:"https://formatjs.io/docs/core-concepts/icu-syntax/"},"ICU")," message format, which allows passing\nvariables, so user can also pass named parameters, which are referenced in translation self and translation strings can\nlook like ",(0,r.kt)("inlineCode",{parentName:"p"},"You have {itemsCount} items in your cart"),". In ideal scenario we'd like something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'<T keyName="cart_content_key" parameters={{itemsCount: 5}}/>\n')),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"My main working tool is React and so I use React as kind of reference implementation")),(0,r.kt)("h3",{id:"translating-imperatively"},"Translating imperatively"),(0,r.kt)("p",null,"Translations can occur not only directly as children in DOM elements, but also in parameters like ",(0,r.kt)("inlineCode",{parentName:"p"},"title"),"\nor ",(0,r.kt)("inlineCode",{parentName:"p"},"aria-label"),". For these cases we can't use component, but we need some user callable function, which will translate\nthe text for him imperatively. E.g.:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"<div title={t('translation_key')}>...</div>\n")),(0,r.kt)("h3",{id:"source-of-data"},"Source of data"),(0,r.kt)("p",null,"We need a way to provide ",(0,r.kt)("inlineCode",{parentName:"p"},"tolgee/core")," instance and ideally we don't want limit it for just one (user might want to use\nmultiple different sources of translations in the same project). Ideal would be to provide the instance globally or to a\nsubtree of components in the application (In React it's exactly what Context API does)."),(0,r.kt)("h2",{id:"implementation-for-react"},"Implementation for React"),(0,r.kt)("p",null,"In React we use context API to provide Tolgee instance to all children:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"export const TolgeeProviderContext = React.createContext(null);\n\nexport const TolgeeProvider = ({config, children}) => {\n  const [tolgee] = useState(new Tolgee(config));\n\n  useEffect(() => {\n    tolgee.run();\n    return () => {\n      tolgee.stop();\n    };\n  }, []);\n\n  return (\n    <TolgeeProviderContext.Provider value={{tolgee}}>\n      {children}\n    </TolgeeProviderContext.Provider>\n  );\n};\n")),(0,r.kt)("p",null,"Now let's look how we can use Tolgee context in ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"export const T = ({ keyName, parameters }) =>\n{\n  const {tolgee} = useContext(TolgeeProviderContext);\n\n  // get initial value\n  const [translated, setTranslated] = useState(\n    tolgee.instant(keyName, parameters)\n  );\n\n  useEffect(() => {\n    // subscribe to translation changes\n    const subscription =\n      tolgee.onTranslationChange.subscribe((data) => {\n        if (data.key === keyName) {\n          setTranslate(tolgee.instant(keyName, parameters));\n        }\n      });\n\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [keyName, parameters]);\n\n  return translated;\n};\n")),(0,r.kt)("p",null,"Tolgee instance holds internal cache with all current translations. So when we call ",(0,r.kt)("inlineCode",{parentName:"p"},"tolgee.instant()"),", we'll get\ncurrent translation of the key with applied parameters, also we can subscribe to translation changes, which happen e.g.\nwhen language is changed or when user manually changes the translation through in-context localization tool."),(0,r.kt)("h3",{id:"imperative-translating-in-react"},"Imperative translating in React"),(0,r.kt)("p",null,"To create simple to use ",(0,r.kt)("inlineCode",{parentName:"p"},"t"),' function in React, we need to somehow "hook" it to component lifecycle as we need not just\nto translate keys, but also subscribe the component to translation changes. Simplest solution (as I might given you a\nhint) is to create hook, which returns this ',(0,r.kt)("inlineCode",{parentName:"p"},"t")," function. Then we have separate ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," function for each component and we\ncan connect it to the component lifecycle. Let's look how that can look like."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"export const useTranslate: () => ReturnFnType = () => {\n  const {tolgee} = useTolgeeContext();\n\n  // dummy state to force component to re-render\n  const [_, setDummyValue] = useState(0);\n  const reRender = () => {\n    setDummyValue((v) => v + 1);\n  };\n\n  // array of used keys\n  const usedKeysRef = useRef(new Set());\n\n  useEffect(() => {\n    const subscription = tolgee.onTranslationChange.subscribe((data) => {\n      // check if we are using this key\n      if (usedKeysRef.current.has(data.key)) {\n        reRender()\n      }\n    });\n\n    return () => subscription.unsubscribe();\n  }, []);\n\n  return (keyName, parameters) => {\n    // remember that this key was used\n    usedKeysRef.current.add(keyName)\n\n    return tolgee.instant(keyName, parameters)\n  };\n};\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"React doesn't have a direct way how to force component to re-render, so we do it through dummy state update.")),(0,r.kt)("p",null,"This hook can be then used in following way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"export const MyComponent = () => {\n  const t = useTranslate()\n\n  return <div title={t('title_key')}>...</div>\n}\n")),(0,r.kt)("p",null,"We basically give user a function and then observe what keys is he using it for. When translation changes, we check if\nit was used before in this component and eventually we force component to re-render."),(0,r.kt)("h4",{id:"notes"},"Notes"),(0,r.kt)("p",null,"Implementation for all frameworks and is quite simplified in order to fit into one article. The core library is in\nreality a bit more complex, also we've completely skipped in-context localization event handlers (that allows user to\nclick on translation), as it is quite complicated subject."),(0,r.kt)("h2",{id:"implementation-for-vuejs"},"Implementation for Vue.js"),(0,r.kt)("p",null,"Vue.js has also concept of providing a context to it's children. We can do this by ",(0,r.kt)("inlineCode",{parentName:"p"},"provide")," method on any component."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"export const TolgeeProvider = {\n  name: 'TolgeeProvider',\n  props: {\n    config: {type: Object, required: true},\n  },\n  created() {\n    const tolgee = new Tolgee({...this.$props.config});\n    this.tolgeeContext.tolgee = tolgee;\n    tolgee.run()\n  },\n  data() {\n    return {\n      tolgeeContext: {\n        tolgee: null,\n        // more reactive properties here\n      },\n    };\n  },\n  provide() {\n    return {\n      tolgeeContext: this.tolgeeContext,\n    };\n  },\n  beforeUnmount() {\n    this.tolgeeContext.tolgee.stop();\n  },\n  render() {\n    this.$slots.default()\n  },\n};\n")),(0,r.kt)("p",null,"Vue is using methods to manage lifecycle of the component, it is quite similar to React class components. Where Vue\nis quite different is that it's using reactive objects - everyting you put inside ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," property, will get turned into\nreactive objects (which are watching for changes), so that way Vue triggers re-renedering. In example above, we are\nputting a whole ",(0,r.kt)("inlineCode",{parentName:"p"},"tolgeeContext")," into data property because in reality we need more things to be passed down and it\nneeds to be reactive."),(0,r.kt)("p",null,"Now let's look how ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," component can work."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"export const T = {\n  name: 'T',\n  inject: ['tolgeeContext'],\n  props: {\n    keyName: {type: String, required: true},\n    parameters: Object,\n  },\n  data() {\n    const tolgeeContext = this.tolgeeContext;\n    return {\n      translation:\n        tolgeeContext.tolgee.instant(\n          this.$props.keyName,\n          this.$props.parameters\n        )\n    };\n  },\n  methods: {\n    translate(data) {\n      if (data.key === this.$props.keyName) {\n        this.$data.translation =\n          tolgeeContext.tolgee.instant(\n            this.$props.keyName,\n            this.$props.parameters\n          )\n      }\n    }\n  },\n  created() {\n    const tolgeeContext = this.tolgeeContext;\n    this.$options.subscription =\n      tolgeeContext.tolgee.onTranslationChange.subscribe(this.translate);\n  },\n  beforeUnmount() {\n    this.$options.subscription.unsubscribe();\n  },\n  render() {\n    return this.$data.translation\n  },\n};\n")),(0,r.kt)("p",null,"Similarly as in React, we use ",(0,r.kt)("inlineCode",{parentName:"p"},"tolgeeContext")," through ",(0,r.kt)("inlineCode",{parentName:"p"},"inject")," property and subscribe to\ntranslation changes in lifecycle methods."),(0,r.kt)("h3",{id:"imperative-translating-in-vue"},"Imperative translating in Vue"),(0,r.kt)("p",null,"As we don't have anything like hooks in Vue, we'll have to use it's ",(0,r.kt)("inlineCode",{parentName:"p"},"Mixin")," api. Mixin is a way how to share logic\nbetween components while using it's lifecycle methods."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"export const TolgeeMixin = {\n  inject: ['tolgeeContext'],\n  beforeCreate() {\n    this.$options.usedKeys = new Set()\n  },\n  created() {\n    const tolgeeContext = this.tolgeeContext;\n    this.$options.subscription =\n      tolgeeContext.tolgee.onTranslationChange.subscribe((data) => {\n        if (this.$options.usedKeys.has(data.key)) {\n          this.$forceUpdate();\n        }\n      });\n  },\n  methods: {\n    $t(keyName, params) {\n      this.$options.usedKeys.add(keyName)\n      const tolgeeContext = this.tolgeeContext;\n      return tolgeeContext.tolgee.instant(keyName, params);\n    },\n  },\n  beforeUnmount() {\n    this.$options.subscription.unsubscribe();\n  },\n};\n")),(0,r.kt)("p",null,"Mixin can then be used following way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<template>\n  <div :title=\"$t('title_key')\">...</div>\n</template>\n\n<script>\nexport const Component = {\n  mixins: [TolgeeMixin],\n};\n<\/script>\n")),(0,r.kt)("p",null,"So here we inject ",(0,r.kt)("inlineCode",{parentName:"p"},"tolgeeContext"),", subscribe into translation changes and add ",(0,r.kt)("inlineCode",{parentName:"p"},"$t")," method, which can then be used by the\nuser. We also maintain a list of keys, which were used and we update the component when they change. Notice that\nVue has explicit method ",(0,r.kt)("inlineCode",{parentName:"p"},"$forceUpdate"),", which causes re-render of the component."),(0,r.kt)("h2",{id:"implementation-in"},"Implementation in"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Svelte and Angular sections are written by Jan Cizmar, as he is the author of the integrations")),(0,r.kt)("p",null,"In Svelte we implemented the provider quite similarly as in Vue and React."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-svelte"},'\x3c!-- TolgeeProvider.svelte --\x3e\n<script>\n  import { onDestroy, onMount, setContext } from "svelte";\n\n  export let config: TolgeeConfig;\n  const tolgee = new Tolgee(config);\n\n  setContext("tolgeeContext", { tolgee });\n\n  onMount(() => tolgee.run());\n  onDestroy(() => tolgee.stop());\n<\/script>\n\n<slot />\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," component that uses the context looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-svelte"},"<script>\n  import { onDestroy, getContext } from \"svelte\";\n\n  export let keyName;\n  export let parameters;\n  const tolgeeContext = getContext('tolgeeContext');\n\n  let translated\n  const translate = () => {\n    translated = tolgeeContext.tolgee.instant(\n      keyName,\n      parameters,\n    );\n  }\n\n  translate();\n  const subscription =\n    tolgeeContext.tolgee.onTranslationChange.subscribe((data) => {\n      if (data.key === keyName) {\n        translate()\n      }\n    });\n\n  onDestroy(() => {\n    subscription.unsubscribe();\n  });\n<\/script>\n\n{translated}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"TolgeeProvider")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," component are very similar to React implementation."),(0,r.kt)("p",null,"The differences are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Svelte has lifecycle methods, React has hooks"),(0,r.kt)("li",{parentName:"ul"},"Context API has is a bit different")),(0,r.kt)("h3",{id:"imperative-translating-in-svelte"},"Imperative translating in Svelte"),(0,r.kt)("p",null,"The biggest difference from React integration is in the ",(0,r.kt)("inlineCode",{parentName:"p"},"getTranslate")," method, which in Svelte returns a Store\ncontaining the method to actually translate the key."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {onDestroy, getContext} from 'svelte';\nimport {derived, writable} from 'svelte/store';\n\nexport const getTranslate = () => {\n  const context = getContext('tolgeeContext');\n  const tolgee = context.tolgee;\n\n  // set of used keys\n  const usedKeys = new Set();\n\n  // dummy store which is updated to forces providing of new translate method\n  const updateStore = writable(0);\n  const update = () => updateStore.update((number) => number + 1);\n\n  const translate = (keyName, params) => {\n    usedKeys.add(keyName);\n    return tolgee.instant(keyName, params);\n  };\n\n  const subscription =\n    tolgee.onTranslationChange.subscribe((data) => {\n      if (usedKeys.has(data.key)) {\n        update();\n      }\n    });\n\n  onDestroy(() => {\n    subscription.unsubscribe();\n  });\n\n  // return new translate method when something is changed\n  return derived(\n    // when updateStore changes, translate function gets changed as well\n    updateStore,\n    () => (keyName, params) => {\n      return translate(keyName, params);\n    }\n  );\n};\n")),(0,r.kt)("p",null,"Example usage of ",(0,r.kt)("inlineCode",{parentName:"p"},"getTranslate")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-svelte"},"<script>\n  const t = getTranslate();\n<\/script>\n\n<div title={$t('title_key')}>...</div>\n")),(0,r.kt)("p",null,"In React the ",(0,r.kt)("inlineCode",{parentName:"p"},"useTranslate")," is hook, which is basically modifying state to force rerender when translation changes and\nthe returned ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," function called by the new render then returns new value."),(0,r.kt)("p",null,"Similar thing happens in Svelte, but there the ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," is actually a Store containing the translating function. That's why\nthere is the ",(0,r.kt)("inlineCode",{parentName:"p"},"$")," before the function call. It means that the value should be re-rendered whenever the Store is updated."),(0,r.kt)("h2",{id:"angular"},"Angular"),(0,r.kt)("p",null,"The most different approach is used in Angular integration. Angular has no concept of provider, instead we can use module, which setups the Tolgee Core library and provides the service, pipe and component to allow translating in the module components."),(0,r.kt)("h3",{id:"the-ngxtolgeemodule"},"The NgxTolgeeModule"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"@NgModule({\n  declarations: [TranslatePipe, STranslatePipe, TComponent],\n  exports: [TranslatePipe, STranslatePipe, TComponent],\n  providers: [],\n})\nexport class NgxTolgeeModule {\n  // @dynamic\n  static forRoot(options: TolgeeConfig): ModuleWithProviders<NgxTolgeeModule> {\n    options = {filesUrlPrefix: '/assets/i18n/', ...options};\n    return {\n      ngModule: NgxTolgeeModule,\n      providers: [\n        TranslateService,\n        TranslationsProvider,\n        {\n          provide: APP_INITIALIZER,\n          useFactory: (provider: TranslationsProvider) => {\n            return async () => await provider.load(options);\n          },\n          deps: [TranslationsProvider, TranslateService],\n          multi: true,\n        },\n        {provide: TolgeeConfig, useValue: options},\n      ],\n    };\n  }\n}\n")),(0,r.kt)("p",null,"Cool thing about this is the factory, which enables us to wait for translations to be loaded before it renders the\napplication to the DOM. In other frameworks, this is handled by loadingFallback props or slots, which are rendered when\ntranslations are loading."),(0,r.kt)("h3",{id:"the-translation-service-and-observables"},"The translation service and Observables"),(0,r.kt)("p",null,"In Angular world RxJs and its Observable interface are very popular. The Observable is similar thing as an event\nemitter. It enables us to emmit new values until we are done and enables us to unsubscribe when we need so. This is\nexactly what we need for our purpose."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import {EventEmitter, Injectable, OnDestroy} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {Tolgee, TranslationData} from '@tolgee/core';\nimport {TolgeeConfig} from './tolgeeConfig';\n\n@Injectable()\nexport class TranslateService implements OnDestroy {\n  constructor(private config: TolgeeConfig) {\n  }\n\n  // Logic creating the Instance of Tolgee and lot of other stuff is ommited\n  // ...\n\n  private _tolgee: Tolgee;\n\n  public get tolgee(): Tolgee {\n    return this._tolgee;\n  }\n\n  public translate(\n    key: string,\n    params = {},\n  ): Observable<string> {\n    return new Observable((subscriber) => {\n      const translate = () => {\n        const translated = this.tolgee.instant(\n          key,\n          params,\n        );\n        subscriber.next(translated);\n      };\n\n      translate();\n\n      const onTranslationChangeSubscription =\n        this.tolgee.onTranslationChange.subscribe((data) => {\n          if (data.key === key) {\n            translate();\n          }\n        });\n\n      return () => {\n        onTranslationChangeSubscription.unsubscribe();\n      };\n    });\n  }\n}\n")),(0,r.kt)("p",null,"The service's ",(0,r.kt)("inlineCode",{parentName:"p"},"translate")," method creates new Observable and emits new value every time translation is changed, which is\nemitted by Tolgee instance from @tolgee/core library. It also returns function, which enables us to unsubscribe."),(0,r.kt)("h3",{id:"the-component-with-t-attribute-selector"},"The component with ",(0,r.kt)("inlineCode",{parentName:"h3"},"t")," attribute selector"),(0,r.kt)("p",null,"As an equivalent to ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," component in React, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"t")," selector, it subscribes to ",(0,r.kt)("inlineCode",{parentName:"p"},"translate")," Observable and changes the result according to the new value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import {Component, ElementRef, Input, OnDestroy, OnInit} from '@angular/core';\nimport {Subscription} from 'rxjs';\nimport {TranslateService} from './translate.service';\nimport {TOLGEE_WRAPPED_ONLY_DATA_ATTRIBUTE} from '@tolgee/core';\n\n@Component({\n  selector: '[t]',\n  template: ``,\n})\nexport class TComponent implements OnInit, OnDestroy {\n  @Input() params?: Record<string, any>;\n  @Input() key: string;\n  subscription: Subscription;\n\n  constructor(\n    private ref: ElementRef,\n    private translateService: TranslateService\n  ) {\n  }\n\n  ngOnInit(): void {\n    const element = this.ref.nativeElement as HTMLElement;\n    element.setAttribute(TOLGEE_WRAPPED_ONLY_DATA_ATTRIBUTE, this.key);\n\n    this.subscription = this.translateService\n      .translate(this.key, this.params, this.default)\n      .subscribe((translated) => {\n        return (element.textContent = translated);\n      });\n  }\n\n  ngOnDestroy(): void {\n    this.subscription.unsubscribe();\n  }\n}\n")),(0,r.kt)("h3",{id:"the-translate-pipe"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"translate")," pipe"),(0,r.kt)("p",null,"Pipe is a feature, which is missing in all the other integrations. It's basically function, which is able to change\nvalue used in template to some other value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import {OnDestroy, Pipe, PipeTransform} from '@angular/core';\nimport {TranslateService} from './translate.service';\nimport {Subscription} from 'rxjs';\n\n@Pipe({\n  name: 'translate',\n  pure: false,\n})\nexport class TranslatePipe implements PipeTransform, OnDestroy {\n  value = '';\n  key: string;\n  params: Record<string, any>;\n  private subscription: Subscription;\n\n  constructor(protected translateService: TranslateService) {\n  }\n\n  ngOnDestroy(): void {\n    this.unsubscribe();\n  }\n\n  transform(\n    key: any,\n    params?: Record<string, any>\n  ): string {\n    if (\n      this.key === key &&\n      JSON.stringify(this.params) === JSON.stringify(params)\n    ) {\n      // parameters unchanged\n      return this.value;\n    }\n\n    this.key = key;\n    this.params = params;\n\n    this.unsubscribe();\n    this.subscription = this.translate(key, params);\n\n    return this.value;\n  }\n\n  private unsubscribe() {\n    this.subscription.unsubscribe();\n  }\n\n  private translate(key, params) {\n    this.translateService.translate(key, params).subscribe((r) => {\n      this.value = r;\n    });\n  }\n}\n")),(0,r.kt)("p",null,"Angular is basically running the transform method every time the user moves mouse or hits some keys, since it is impure\npipe, which may return different result for the same input. That happens when language is changed: same key and params,\ndifferent result."),(0,r.kt)("p",null,"In comparison to other frameworks it seems that Angular library needs a bit more code and the integration is more\ncomplicated."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,'It is interesting, how these frameworks/libraries take inspiration from each other. Svelte being the newest has something from everyone and the code seems very natural and clean. Vue takes inspiration from both Angular and React and is kinda compromise between them. Then you have React, which stands out with hooks and JSX. And Angular taking inspiration from "classic" Model-View-Controller schema, which is familiar to backend developers.'),(0,r.kt)("p",null,"We'll be glad if you let us know how to improve/simplify an implementation in any of these frameworks/libraries. We don't claim that we know all these frameworks that well. I've used Vue seriously for the first time and Jan was learning Svelte from scratch, while he was implementing this (their documentation is outstanding)."))}u.isMDXComponent=!0},88630:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tolgee-dev-schema-710c3293125c37b9aab5ca3b628e4584.png"}}]);